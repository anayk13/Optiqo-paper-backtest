"""
Example: Loading and Running LLM-Generated Strategies
Demonstrates how to integrate LLM-generated strategies with the production engine.
"""

import asyncio
import sys
import os
from pathlib import Path

# Add project root to path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

from production_main import ProductionTradingEngine
from engine.strategy_loader import StrategyLoader


# Example LLM-generated strategy code
LLM_GENERATED_STRATEGY_CODE = '''
import pandas as pd
import numpy as np
from strategies.enhanced_base_strategy import EnhancedBaseStrategy

class LLMMomentumStrategy(EnhancedBaseStrategy):
    """
    LLM-generated momentum strategy with advanced features.
    This strategy was generated by an AI based on user requirements.
    """
    
    def __init__(self, event_engine, logger, executor_account_name, strategy_id=None, strategy_manager=None, **kwargs):
        super().__init__(event_engine, logger, executor_account_name, strategy_id, strategy_manager, **kwargs)
        
        # Strategy parameters
        self.lookback_short = self.params.get('lookback_short', 5)
        self.lookback_long = self.params.get('lookback_long', 20)
        self.momentum_threshold = self.params.get('momentum_threshold', 0.02)
        self.volume_threshold = self.params.get('volume_threshold', 1000000)
        self.rsi_oversold = self.params.get('rsi_oversold', 30)
        self.rsi_overbought = self.params.get('rsi_overbought', 70)
        
        # Track multiple symbols
        self.tracked_symbols = ['NSE_EQ_INFY', 'NSE_EQ_TCS', 'BSE_EQ_RELIANCE']
        for symbol in self.tracked_symbols:
            self.add_tracked_symbol(symbol)
    
    def generate_signals(self, data, context=None):
        """Generate sophisticated momentum-based signals"""
        signals = pd.DataFrame(index=data.index)
        signals['Signal'] = 0
        signals['Confidence'] = 0.0
        
        if len(data) < self.lookback_long:
            return signals
        
        # Calculate technical indicators
        short_ma = data['close'].rolling(window=self.lookback_short).mean()
        long_ma = data['close'].rolling(window=self.lookback_long).mean()
        
        # Calculate RSI
        rsi = self._calculate_rsi(data['close'], 14)
        
        # Calculate momentum
        momentum = (data['close'] / data['close'].shift(self.lookback_long) - 1)
        
        # Calculate volume ratio
        volume_ratio = data['volume'] / data['volume'].rolling(window=20).mean()
        
        # Generate signals with multiple conditions
        bullish_condition = (
            (short_ma > long_ma) &  # MA crossover
            (momentum > self.momentum_threshold) &  # Strong momentum
            (rsi < self.rsi_overbought) &  # Not overbought
            (volume_ratio > 1.2)  # Above average volume
        )
        
        bearish_condition = (
            (short_ma < long_ma) &  # MA crossover
            (momentum < -self.momentum_threshold) &  # Strong negative momentum
            (rsi > self.rsi_oversold) &  # Not oversold
            (volume_ratio > 1.2)  # Above average volume
        )
        
        # Set signals
        signals.loc[bullish_condition, 'Signal'] = 1
        signals.loc[bearish_condition, 'Signal'] = -1
        
        # Calculate confidence based on multiple factors
        signals['Confidence'] = self._calculate_confidence(
            momentum, rsi, volume_ratio, short_ma, long_ma
        )
        
        return signals
    
    def _calculate_rsi(self, prices, window=14):
        """Calculate RSI indicator"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def _calculate_confidence(self, momentum, rsi, volume_ratio, short_ma, long_ma):
        """Calculate signal confidence based on multiple factors"""
        confidence = pd.Series(0.0, index=momentum.index)
        
        # Momentum strength (0-0.4)
        momentum_strength = np.clip(np.abs(momentum) / 0.1, 0, 1) * 0.4
        
        # RSI position (0-0.3)
        rsi_position = np.where(
            (rsi > 30) & (rsi < 70), 
            np.abs(rsi - 50) / 20, 
            0
        ) * 0.3
        
        # Volume confirmation (0-0.2)
        volume_confirmation = np.clip(volume_ratio - 1, 0, 2) * 0.1
        
        # MA separation (0-0.1)
        ma_separation = np.clip(np.abs(short_ma - long_ma) / long_ma, 0, 0.05) * 2
        
        confidence = momentum_strength + rsi_position + volume_confirmation + ma_separation
        return np.clip(confidence, 0, 1)
    
    def position_sizing(self, data):
        """Dynamic position sizing based on confidence and volatility"""
        if 'Confidence' not in data.columns:
            return pd.Series(1, index=data.index)
        
        # Base position size
        base_size = 100
        
        # Adjust based on confidence
        confidence_multiplier = data['Confidence']
        
        # Adjust based on volatility (lower volatility = larger position)
        volatility = data['close'].rolling(window=20).std() / data['close'].rolling(window=20).mean()
        volatility_multiplier = 1 / (1 + volatility)
        
        # Final position size
        position_size = base_size * confidence_multiplier * volatility_multiplier
        
        return position_size.clip(10, 500)  # Min 10, Max 500
    
    def risk_management(self, data):
        """Enhanced risk management"""
        if 'Signal' not in data.columns:
            return data
        
        # Add stop loss and take profit levels
        data['Stop_Loss'] = 0.0
        data['Take_Profit'] = 0.0
        
        # Calculate stop loss and take profit based on ATR
        atr = self._calculate_atr(data, 14)
        
        for i in range(len(data)):
            if data.iloc[i]['Signal'] != 0:
                current_price = data.iloc[i]['close']
                atr_value = atr.iloc[i]
                
                if data.iloc[i]['Signal'] > 0:  # Long position
                    data.iloc[i, data.columns.get_loc('Stop_Loss')] = current_price - (2 * atr_value)
                    data.iloc[i, data.columns.get_loc('Take_Profit')] = current_price + (3 * atr_value)
                else:  # Short position
                    data.iloc[i, data.columns.get_loc('Stop_Loss')] = current_price + (2 * atr_value)
                    data.iloc[i, data.columns.get_loc('Take_Profit')] = current_price - (3 * atr_value)
        
        return data
    
    def _calculate_atr(self, data, window=14):
        """Calculate Average True Range"""
        high_low = data['high'] - data['low']
        high_close = np.abs(data['high'] - data['close'].shift())
        low_close = np.abs(data['low'] - data['close'].shift())
        
        true_range = np.maximum(high_low, np.maximum(high_close, low_close))
        atr = true_range.rolling(window=window).mean()
        
        return atr
    
    def description(self):
        return "LLM-generated momentum strategy with RSI, volume, and volatility filters"
    
    def parameter_schema(self):
        return {
            "lookback_short": {"type": "int", "min": 3, "max": 20, "default": 5},
            "lookback_long": {"type": "int", "min": 10, "max": 50, "default": 20},
            "momentum_threshold": {"type": "float", "min": 0.001, "max": 0.1, "default": 0.02},
            "volume_threshold": {"type": "int", "min": 100000, "max": 10000000, "default": 1000000},
            "rsi_oversold": {"type": "int", "min": 10, "max": 40, "default": 30},
            "rsi_overbought": {"type": "int", "min": 60, "max": 90, "default": 70}
        }
'''


async def main():
    """Example of loading and running LLM-generated strategies"""
    
    print("üöÄ LLM Strategy Integration Example")
    print("=" * 50)
    
    # Initialize strategy loader
    strategy_loader = StrategyLoader()
    
    # Load LLM-generated strategy from code
    print("üì• Loading LLM-generated strategy...")
    strategy_class = strategy_loader.load_strategy_from_code(
        strategy_code=LLM_GENERATED_STRATEGY_CODE,
        strategy_name="LLM_Momentum_Strategy",
        strategy_class_name="LLMMomentumStrategy"
    )
    
    print(f"‚úÖ Strategy loaded: {strategy_class.__name__}")
    
    # Get strategy metadata
    metadata = strategy_loader.get_strategy_metadata("LLM_Momentum_Strategy")
    print(f"üìä Strategy Description: {metadata['description']}")
    print(f"‚öôÔ∏è  Parameters: {metadata['parameter_schema']}")
    
    # Initialize production engine
    print("\nüè≠ Initializing Production Trading Engine...")
    engine = ProductionTradingEngine("config/production_config.yaml")
    await engine.initialize()
    
    # Add the LLM-generated strategy
    print("\n‚ûï Adding LLM strategy to engine...")
    strategy_config = {
        'lookback_short': 5,
        'lookback_long': 20,
        'momentum_threshold': 0.02,
        'volume_threshold': 1000000,
        'rsi_oversold': 30,
        'rsi_overbought': 70,
        'max_position_size': 1000,
        'stop_loss_pct': 0.02,
        'take_profit_pct': 0.04
    }
    
    strategy_id = await engine.add_strategy(
        strategy_class=strategy_class,
        strategy_name="LLM_Momentum_Strategy",
        config=strategy_config
    )
    
    print(f"‚úÖ Strategy added with ID: {strategy_id}")
    
    # Get strategy status
    status = await engine.get_strategy_status(strategy_id)
    print(f"üìà Strategy Status: {status['status']}")
    
    # Run the engine for a short time (in production, this would run indefinitely)
    print("\nüèÉ Running engine for 30 seconds...")
    print("Press Ctrl+C to stop early")
    
    try:
        # Start the engine in a separate task
        engine_task = asyncio.create_task(engine.run())
        
        # Wait for 30 seconds or until interrupted
        await asyncio.wait_for(engine_task, timeout=30.0)
        
    except asyncio.TimeoutError:
        print("\n‚è∞ 30 seconds elapsed, stopping engine...")
        engine.is_running = False
    except KeyboardInterrupt:
        print("\nüõë Interrupted by user, stopping engine...")
        engine.is_running = False
    
    # Get final status
    print("\nüìä Final Strategy Status:")
    final_status = await engine.get_strategy_status(strategy_id)
    print(f"Status: {final_status['status']}")
    print(f"Error Count: {final_status['error_count']}")
    print(f"Resource Usage: {final_status['resource_usage']}")
    
    print("\n‚úÖ Example completed successfully!")


if __name__ == "__main__":
    asyncio.run(main())
