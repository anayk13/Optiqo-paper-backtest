import asyncio
from typing import Type
from .event_engine import EventEngine, MarketEvent, SignalEvent, OrderEvent, FillEvent
from strategies.base_strategy import BaseStrategy
from .portfolio import PortfolioManager
from .trade_executor import TradeExecutor
from .risk_manager import RiskManager
from .logger import get_logger # Ensure get_logger is imported

class StrategyAdapter:
    """
    Adapts market data events for the strategy and handles signals from the strategy.
    It sits between the EventEngine, Strategy, PortfolioManager, TradeExecutor, and RiskManager.
    """
    def __init__(self,
                 event_engine: EventEngine,
                 strategy: BaseStrategy,
                 portfolio_manager: PortfolioManager,
                 trade_executor: TradeExecutor,
                 risk_manager: RiskManager,
                 logger):
        self.event_engine = event_engine
        self.strategy = strategy
        self.portfolio_manager = portfolio_manager
        self.trade_executor = trade_executor
        self.risk_manager = risk_manager
        self.logger = logger # This logger is passed from main.py
        self.logger.info(f"StrategyAdapter initialized for strategy: {self.strategy.__class__.__name__}")
    async def on_fill_event(self, event: FillEvent):
        """Pass fill event to the strategy for internal state updates."""
        self.logger.info(f"Received FillEvent for Order ID: {event.order_id}, passing to strategy.")
        await self.strategy.handle_fill_event(event)
    async def on_market_event(self, event: MarketEvent):
        """
        Processes MarketEvents and forwards them to the strategy.
        The strategy might generate SignalEvents in response.
        """
        self.logger.debug(f"StrategyAdapter received MarketEvent for {event.instrument_token}. Forwarding to strategy.") # <--- ADDED THIS DEBUG LOG
        await self.strategy.handle_market_event(event)

    async def on_signal_event(self, event: SignalEvent):
        """
        Processes SignalEvents generated by the strategy.
        It then validates the order with RiskManager and converts it to an OrderEvent.
        """
        self.logger.debug(f"StrategyAdapter received SignalEvent for {event.instrument_token}. Processing...")
        self.logger.info(f"Adapter received SignalEvent from strategy {event.strategy_id}: {event.signal_type} {event.quantity} of {event.instrument_token}")

        is_valid, margin_req, brokerage_req = await self.risk_manager.validate_order(
            exchange_token=event.instrument_token,
            quantity=event.quantity,
            product=event.product_type,
            transaction_type=event.signal_type,
            trade_type="entry",
            price=event.price
        )

        if is_valid:
            self.logger.info(f"Signal {event.instrument_token} validated by RiskManager. Margin: {margin_req}, Brokerage: {brokerage_req}")

            order_event = OrderEvent(
                instrument_token=event.instrument_token,
                transaction_type=event.signal_type,
                quantity=event.quantity,
                product=event.product_type,
                validity=event.validity,
                order_type=event.order_type,
                price=event.price,
                tag=event.tag
            )
            self.logger.info(f"Converting SignalEvent to OrderEvent for {event.instrument_token}. Putting on queue.")
            await self.event_engine.put(order_event)
        else:
            self.logger.warning(f"Signal {event.instrument_token} REJECTED by RiskManager.")