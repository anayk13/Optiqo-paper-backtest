import asyncio
import collections
from typing import Dict, Any, Callable
import logging
from .logger import get_logger

class Event:
    """Base class for all events."""
    def __init__(self, event_type: str):
        self.event_type = event_type

class MarketEvent(Event):
    """
    Handles the event of receiving new market data (tick or bar).
    Contains the market data itself.
    """
    def __init__(self, instrument_token: str, ltp: float, timestamp: float):
        super().__init__("MarketEvent") # The string name is for logging/identification
        self.instrument_token = instrument_token
        self.ltp = ltp
        self.timestamp = timestamp

class SignalEvent(Event):
    """
    Handles the event of a trading signal being generated by a strategy.
    Contains details needed to place an order.
    """
    def __init__(self,
                 instrument_token: str,
                 strategy_id: str,
                 signal_type: str, # e.g., "BUY", "SELL"
                 quantity: int,
                 price: float = 0.0,
                 order_type: str = "MARKET", # "MARKET", "LIMIT"
                 product_type: str = "MIS", # e.g., "MIS", "CNC", "NORMAL"
                 validity: str = "DAY", # e.g., "DAY", "IOC"
                 tag: str = ""):
        super().__init__("SignalEvent")
        self.instrument_token = instrument_token
        self.strategy_id = strategy_id
        self.signal_type = signal_type
        self.quantity = quantity
        self.price = price
        self.order_type = order_type
        self.product_type = product_type
        self.validity = validity
        self.tag = tag

class OrderEvent(Event):
    """
    Handles the event of an order being created (from a signal).
    Contains all details required to place an order with the broker.
    """
    def __init__(self,
                 instrument_token: str,
                 transaction_type: str, # "BUY", "SELL"
                 quantity: int,
                 product: str, # "MIS", "CNC", etc.
                 validity: str, # "DAY", "IOC", etc.
                 order_type: str = 'MARKET', # "MARKET", "LIMIT"
                 price: float = 0,
                 trigger_price: float = 0,
                 disclosed_quantity: int = 0,
                 is_amo: bool = False,
                 tag: str = ''):
        super().__init__("OrderEvent")
        self.instrument_token = instrument_token
        self.transaction_type = transaction_type
        self.quantity = quantity
        self.product = product
        self.validity = validity
        self.order_type = order_type
        self.price = price
        self.trigger_price = trigger_price
        self.disclosed_quantity = disclosed_quantity
        self.is_amo = is_amo
        self.tag = tag

class FillEvent(Event):
    """
    Handles the event of an order being filled by the broker.
    Contains details about the executed trade.
    """
    def __init__(self,
                 order_id: str,
                 instrument_token: str,
                 exchange_order_id: str,
                 transaction_type: str,
                 quantity: int,
                 price: float,
                 brokerage: float,
                 fill_timestamp: float):
        super().__init__("FillEvent")
        self.order_id = order_id
        self.instrument_token = instrument_token
        self.exchange_order_id = exchange_order_id
        self.transaction_type = transaction_type
        self.quantity = quantity
        self.price = price
        self.brokerage = brokerage
        self.fill_timestamp = fill_timestamp


class EventEngine:
    """EventEngine is responsible for managing and dispatching events throughout the trading system.
    It maintains an event queue and dispatches events to registered handlers."""
    def __init__(self, queue_maxsize: int = 0, logger_level: int = logging.INFO):
        self.handlers: Dict[str, Callable[[Event], None]] = collections.defaultdict(list)
        self.active = False
        # Initialize logger with the specified level
        self.logger = get_logger(main_folder_name="event_engine", level=logger_level)
        self.task = None
        self.queue = asyncio.Queue(maxsize=queue_maxsize)
        self.logger.info("âœ… EventEngine initialized.")

    def register_handler(self, event_type: type, handler: Callable[[Event], None]):
        """Register a handler for a specific event type."""
        self.handlers[event_type.__name__].append(handler)
        self.logger.info(f"Registered handler for {event_type.__name__} event.")

    def unregister_handler(self, event_type: type, handler: Callable[[Event], None]):
        """Unregister a handler for a specific event type."""
        if handler in self.handlers[event_type.__name__]:
            self.handlers[event_type.__name__].remove(handler)
            self.logger.info(f"Unregistered handler for {event_type.__name__} event.")

    async def put(self, event: Event):
        """Put a new event onto the queue."""
        await self.queue.put(event)

    async def run(self):
        """
        Starts the engine and runs the internal loop to process events.
        This method should be run as a background task (e.g., with asyncio.create_task).
        """
        if self.active:
            self.logger.warning("[EventEngine] Event loop is already running.")
            return

        self.active = True
        self.logger.info("[EventEngine] Starting event loop...")
        while self.active:
            try:
                event = await self.queue.get()
                self.logger.debug(f"[EventEngine] Retrieved event from queue: Type='{event.event_type}', Class='{type(event).__name__}'")
            except asyncio.CancelledError:
                self.logger.info("[EventEngine] Event loop cancelled.")
                break
            except Exception as e:
                self.logger.error(f"[EventEngine] Error while getting event from queue: {e}", exc_info=True)
                await asyncio.sleep(0.001)
                continue

            event_name = type(event).__name__
            if event_name in self.handlers:
                self.logger.debug(f"Dispatching {event_name} event to {len(self.handlers[event_name])} handlers.")
                for handler in self.handlers[event_name]:
                    try:
                        await handler(event)
                    except Exception as e:
                        self.logger.error(f"Error processing {event_name} event with handler {handler.__name__}: {e}", exc_info=True)
            else:
                self.logger.debug(f"No handlers registered for event type: {event_name}")

    async def stop(self):
        """Stop the event engine's processing loop."""
        if self.active:
            self.active = False
            self.logger.info("[EventEngine] Event loop stopped.")
        else:
            self.logger.warning("EventEngine is not running.")